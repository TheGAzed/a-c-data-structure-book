\chapter{Queue} \label{ch:queue}

Imagine you're waiting for your daily calory intake, lunch, in the school and you see a queue. When one person gets their lunch the entire queue moves one person to the front, because, logically, the entire cafeteria won't move to the next person.

But that's NOT how queues in programming work. If each person is a single element and the cafeteria is at the current place of the first person in the queue, then you don't want to move each element to the cafeteria, but move the cafeteria itself. So we have a current pointer/index/position which, after getting rid of the first element, we go/increment/move to the second one, and so on.

Going back to \autoref{ch:stack} \nameref{ch:stack}'s chess analogy, when we put those moves into the stack we're kind of pulling them from an array of moves from the front tto the back. Now lets say there're move moves going on, plus we want to play back and forth the moves which were already played without waiting for the game to finish. To solve this we can pipe the moves into a special queue, then push elements from the queue into stack one. If we want to go to the beginning, then we push the moves from the stack one into stack two. To play all the way to the latest move, all that's left is to first push all the elements from stack two into stack one, and push all moves from the queue into stack one. The top element in stack is the latest move, see \autoref{fig:chess-queue-stack}.

\begin{figure}[p]
    \centering
    \includegraphics[angle=90, height=0.965\textheight]{figures/queue/chess-queue-stack}
    \caption{Visual example of two stacks and a queue being used to track the chess game.}
    \label{fig:chess-queue-stack}
\end{figure}

\section{Implementations of a queue}

Similarly to stacks, there are also two ways to implement queues:

\begin{itemize}
    \item Singly linked lists
    \item Static arrays (not dynamic)
\end{itemize}

\subsection{The free linked list}

Usually when implementing a queue using linked lists we create a list structure that ahs one reference to the head, for access and removal; and to the tail node, for pushing elements. 

However, there is also a slightly better way to implement them, which is to use circular lists. The next subsection will talk about circular arrays, but we can also use circular lists, kinda like \autoref{fig:circular-list}. Hear me out, this won't work if we only have a reference to the head, so lets go with the next best thing - the tail. The list will be circular, thus the tail's next node will be the head. 

\begin{figure}
    \centering
    \includegraphics[width=0.6\textwidth]{figures/queue/circular-list}
    \caption{Visual representation of a circular singly linked list.}
    \label{fig:circular-list}
\end{figure}

This makes access and removal as simple as getting the the head from the tail, also adding elements is easy since we just make the new node's next reference the head and change tail's next to new node, see \autoref{fig:list-queue}. The downside is that circular linked lists are more complex than standard, but by just having one, the tail, node pointer we can decrease the size of the structure a bit (or a whopping 32/64 bits at that).

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{figures/queue/list-queue}
    \caption{Example of adding (top) and removing (bottom) an element from a circular singly linked list queue.}
    \label{fig:list-queue}
\end{figure}
